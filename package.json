{
  "name": "two-way-rest",
  "version": "0.0.8",
  "description": "Two-Way-Rest architecture for react-redux",
  "main": "dist/index.js",
  "scripts": {
    "test": "NODE_ENV=test mocha --compilers js:babel-core/register --require './__test__/test_helper.js' './__test__/*_spec.js' --recursive",
    "test:watch": "npm run test -- --watch",
    "build": "babel lib --out-dir dist",
    "pgtR": "pgt -r",
    "pgtW": "pgt -w",
    "pgt": "pgt",
    "build:watch": "babel lib --watch --out-dir dist"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/l2silver/two-way-rest.git"
  },
  "keywords": [
    "two-way-rest",
    "react-redux"
  ],
  "author": {
    "name": "Leigh Silverstein"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/l2silver/two-way-rest/issues"
  },
  "homepage": "https://github.com/l2silver/two-way-rest#readme",
  "dependencies": {
    "bluebird": "^3.3.1",
    "form-data": "^1.0.0-rc3",
    "i": "^0.3.4",
    "immutable": "^3.7.6",
    "methods": "^1.1.2",
    "promise": "^7.1.1",
    "react": "^15.0.0",
    "react-dom": "^15.0.0",
    "react-redux": "^4.4.0",
    "react-router": "^2.0.0",
    "react-router-redux": "^4.0.2",
    "redux": "^3.3.1",
    "redux-batched-actions": "^0.1.2",
    "superagent": "^1.8.0-beta.2",
    "superagent-promise": "^1.1.0"
  },
  "devDependencies": {
    "babel-cli": "^6.6.5",
    "babel-core": "^6.6.5",
    "babel-preset-es2015": "^6.5.0",
    "babel-preset-react": "^6.5.0",
    "chai": "^3.5.0",
    "chai-as-promised": "^5.2.0",
    "chai-immutable": "^1.5.3",
    "jsdom": "^8.1.0",
    "mocha": "^2.4.5",
    "nock": "^7.2.2",
    "pagitter": "0.0.2",
    "react-addons-test-utils": "^0.15.0",
    "skin-deep": "^0.14.0"
  },
  "gitHead": "6fec3cefd1a29fa9efd92c4605ade0c844ae3c27",
  "readme": "# Two-Way-Rest\n\nA lot of things, but more specifically a react-redux plugin that facilitates changes to the state and backend data sources.\n\nExample:\n```\n<TWRCreate tree={[‘users’]}>\n <input type=’text’ name=’name’ />\n <input type=’submit’ />\n</TWRCreate>\n```\nAfter submitting this magic ‘form’, if no errors are thrown, the state is updated with a new user, and the backend is updated with a new row (...or whatever).\n\nSuppose that instead of creating a user, you wanted to update a user\n```\n<TWRUpdate instance={userInstance}>\n\t<input type=’text’ name=’name’ />\n\t<input type=’submit’ />\n</TWRUpdate>\n```\nAgain, if successful, the form updates both the frontend and the backend. \n\n*A user instance is simply a regular user object with a special tree property:*  \n{id: 1, name: ‘Joe’, **tree: [‘users’, 1]**}\n\nSuppose that instead of updating a user’s frontend and backend, you just wanted to update the frontend.\n\n```\n<TWRUpdateFront instance={userInstance}>\n\t<input type=’text’ name=’visible’ value=’true’ />\n\t<input type=’submit’ />\n</TWRUpdateFront>\n```\nNow your frontend user has a new property(or updates an old property) called visible, and its value is true. \n\n## Motivation:\n\nI'm from the trenches. I build relatively simple websites for small businesses, where the priority is stability and development speed. When I started working with redux, I loved the structure, but hated the steps. Something as simple as toggling a button meant changing the react component, the action creator and the reducer. This process also meant extracting the code away from the react components, which felt counter intuitive, since one of the advantages of react is the code being visible while constructing the DOM. I built two-way-rest to solve these issues.\n\n## Setup:\n\n##### Requirements: \nReact  \nRedux  \nReact-Redux\ntwo-way-rest \n\nProper Setup Example.\n```\nimport { createStore, combineReducers} from 'redux';\nimport {setAddress, setStore} from 'two-way-rest';\nimport rootReducer from './reducers/index';\n\n//We setup the address for backend ajax queries\nsetAddress('http://remoteurl.com');\n\nconst store = createStore(\n\tcombineReducers(rootReducer)\n);\n//We send two-way-rest an exact copy of the store\nsetStore(store);\n\nReactDOM.render(\n  <Provider store={store}>\n    <MyRootComponent />\n  </Provider>,\n  rootEl\n)\n```\n*Although the two-way-rest plugin does not need the combineReducers function from redux, it does require the same state reducer format:*\n```\nfullState = {reducerName_1: reducerState_1, ...}\n```\n\n#### Once the initial setup is complete, we’re free to do a little more setup…\n\nIn order for these special forms to work, we need to create a parent component to hold them.\n```\n<DeclareReducer reducer=’reducerName’>\n{this.props.children}\n</DeclareReducer>\n```\nDeclareReducer is setting up a reducer context property that all of its form children will have access to. Our magical forms need to know which reducer to use. (Although it’s perfectly alright to just use one reducer, as we’ll be using another tool to separate reduction code)\n\nThe last step is to merge our Two-Way-Rest reducer with any reducers that are going to invoke the Two-Way-Rest architecture.\n\n*reducerName.js*\n```\nconst normalReducerSwitch  = function(state, action){...};\nconst twoWayRestSwitch = generateRestSwitch('reducerName');\nexport default combineSwitches([normalReducerSwitch, twoWayRestSwitch]);\n\n```\nWe need to make certain the state is an immutable map object, so the twoWayRestSwitch should always be last. The immutable library is an integral component of two-way-rest. \n\n\n# Inner Workings\n### Frontend Relational Immutable Database\nTwo-way-rest is powered by a frontend pseudo-relational database called globe. Every reducer's state is a globe, and changes to the globe are generally made by passing it either an object, or an array of objects.\n\n### Substate\nEvery globe has a Substate property which holds the intermittent state of an instance before it is either created, updated, or destroyed.\n\n### Components\nThere are two types of two-way-rest components: Getters and Posters. Getters retrieve instances, and Posters mutate instances. Getters include index and show components, and Posters are creates, update, and destroy. Every component sends an instance of itself to the props.instance(s) of its children, however while Getters send the actual instance, Posters send a substate instance if it exists. (Substate instances are created on errors or successes )\n\n### REST Expectations\nIndex: Returns an array\nEverything else: Returns an object\nErrors: Object with an errors property\n\n### Component Actioncycle\nAll two-way-rest components have the same actioncycle that can be tapped into by declaring function using the prop of the appropriate name\n\ncallforward-->\ndefaultAction-->\nonSuccessCB || onFailureCB-->\ncallback\n\nThese functions are wrapped in bluebird's Promise.Method, so they accept promises. They take a single parameter, args, which is an immutable Map object (from immutableJS), and must return an args Map with the same properties. \n\nThe args Map:\nreducer: <string> name of reducer\ntree: <List:Immutable> frontend/backend location of instance\noutTree: <List:Immutable> the frontend location for the response from the backend (defaults to tree)\npath: <string> url starting from http://remoteurl.com/... (defaults to tree) + this.props.endPath <string> rest action like 'edit', 'show', etc.\nform: <DOM:element> the entire component element\ncontent: <Map:Immutable> this.props.content object\ncallforward: <function>\ncallback: <function>\nonSuccessCB: <function>\nonFailureCB: <function>\nonSuccess: <object> passed to instance on success\nonFailure: <object> passed to instance on failure\nupload: <boolean> is one of the fields in the component a file field\nforce: <boolean> should a component refire its standard ajax call everytime it is updated\nparent: <boolean> true for CreateChildComponents\nid: <string> declared using this.props.id, forces a create component to use the declared id\ntwr: <Component> the component itself\nresponse: <object | array> declared using this.props.response, skips ajax call and returns response\ndispatch: <function> disptach function\ngetState: <getState> getState function\n\n\n# Usage\n*For a working example, please checkout the two-way-rest-boilerplate*\nhttp://github.com/l2silver/two-way-rest-boilerplate\n\n# Component Properties\n```\n<TWR* properties...>\n```\n__tree__  \ntype: string  \npurpose: the backend and frontend location of where a TWR component will act  \nexample_1: \n```\nusers/1' (used for updates/destructions of a specific instance)  \n== 'http://remoteurl/users/1' (backend) \n== reducerState.immutable = {users: {1: {id: 1, name: 'joe'}}} (frontend)\n```\n\nexample_2: \n```\n'users' (used for create/index of a specific instance)  \n== 'http://remoteurl/users' (backend) \n== reducerState.immutable = {users: {...the results of a create/index} (frontend)\n```\n\n__location__\ntype: string url\npurpose: parsed to find the tree of an instance\nexample_1: \n```\n<TWRShow location='/admin/users/1/edit' > ==> tree = ['users', '1'] \n(Starts parse at reducer name if reducer name is in url, \nremoves rest words like index, edit, and create from the end of a url)\n```\n\n__instance__\ntype: immutable object with tree and _globeTWR property\npurpose: the frontend representation of a backend object\nexample_1: \n```\n<TWRShow tree='users/1'> ==> sends its children an \n\tinstance prop of the get response to http://remoteUrl/users/1\n<TWRUpdate instance={ this.props.instance} /> ==> uses the \n\tinstance prop's tree set the tree of the component \n```\nexample_2:  \n```\nthis.props.instance.gex('children') ==> an array of child instances\n```\n\nexample_3:  \n```\nthis.props.instance.gex('child') ==> a child instance\n```\n\n__outTree__\ntype: string\npurpose: change the frontend location of where the results should be merged with.\nexample_1: \n```\n<TWRShow tree='users/1' outTree='users/2'> ==> Get the user 1 backend\ninstance and replace the user 2 frontend instance with it\n```\n\n__replace__\ntype: Function\npurpose: replace the component's DOM with a new DOM that has access to all of the component's functions\nexample_1: \n```\n<TWRShow tree='users/1' replace={(user_1)=>{\n\tconsole.log(user_1.instance(), 'returns the frontend instance')\n\treturn <p>{user_1.instance().get('name')}</p>\n}}\n```\n\n__custom__\ntype: Function\npurpose: return a custom reducer function that takes the reducer state as an argument and returns a new reducer state\nexample_1: \n```\n<TWRShow tree='users/1' replace={(user_1)=>{\n\treturn <TWRCreate onClick={()=>{\n\t\tuser_1.custom((state)=>state.set('name', 'Example'))\n\t}} /> \n}} />==> \n```\n\n__customAction__\ntype: Function\npurpose: an action creator for custom functions\nexample_1: \n```\n<TWRUpdate tree='users/1' callforward={(args)=>{\n\targs.get('dispatch')(\n\t\targs.get('twr').customAction(\n\t\t\t(state)=>state.set('name', 'Example')\n\t))\n\treturn args\n\t\n}} />\n\n__forceRender__\ntype: boolean\npurpose: by default, the index and show components will only render the children if their instances exist. When forceRender is true, those components will render their children no matter what.\nexample_1: \n```\n<TWRShow forceRender='true' tree='users/1' >\n\t<p>I show no matter what! </p>\n</TWRShow>\n```\n\n__force__\ntype: boolean\npurpose: the index and show components will only fire a network request once per instance in the same reducer state. To fire everytime a component is mounted, set force to true.\nexample_1: \n```\n<TWRShow force='true' tree='users/1' >\n\t<p>A new network request everytime the component is mounted</p>\n</TWRShow>\n```\n\n__tag__\ntype: string\npurpose: change the element wrapping a TWR component to specific tag\nexample_1: \n```\n<TWRShow tag='div' tree='users/1' >\n\t</p>\n</TWRShow> => <div><p /></div>\n```\n\n",
  "readmeFilename": "README.md",
  "_id": "two-way-rest@0.0.4",
  "_shasum": "c20d87925e86b84095a914d164414c498792a8d7",
  "_from": "git+https://github.com/l2silver/two-way-rest.git",
  "_resolved": "git+https://github.com/l2silver/two-way-rest.git#6fec3cefd1a29fa9efd92c4605ade0c844ae3c27"
}
